"""
æ™ºèƒ½æ¸—é€æµ‹è¯• Agent ç³»ç»Ÿ
åŸºäº LLM + ä»£ç ç”Ÿæˆ + æ²™ç®±æ‰§è¡Œçš„è‡ªåŠ¨åŒ–æ¸—é€æµ‹è¯•æ¡†æ¶
"""

import os
import json
import subprocess
import traceback
from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime
from abc import ABC, abstractmethod


# ============================================================
# 1. å®‰å…¨å·¥å…·æ¥å£å±‚
# ============================================================
class SecurityToolInterface(ABC):
    """å®‰å…¨å·¥å…·æŠ½è±¡æ¥å£"""
    
    @abstractmethod
    def get_tool_description(self) -> str:
        """è¿”å›å·¥å…·æè¿°ï¼Œç”¨äº LLM ç†è§£"""
        pass
    
    @abstractmethod
    def execute(self, *args, **kwargs) -> Any:
        """æ‰§è¡Œå·¥å…·"""
        pass


class NmapTool(SecurityToolInterface):
    """çœŸå®çš„ç«¯å£æ‰«æå·¥å…·"""
    
    def get_tool_description(self) -> str:
        return """
        nmap_scan(target: str, scan_type: str = "common") -> dict
        - å¯¹ç›®æ ‡è¿›è¡ŒçœŸå®çš„ç«¯å£æ‰«æ
        - target: IPåœ°å€æˆ–åŸŸå
        - scan_type: æ‰«æç±»å‹ ("common"=å¸¸è§ç«¯å£, "full"=å…¨ç«¯å£, "quick"=å¿«é€Ÿæ‰«æ)
        - è¿”å›: åŒ…å«å¼€æ”¾ç«¯å£ã€æœåŠ¡ç‰ˆæœ¬ç­‰ä¿¡æ¯çš„å­—å…¸
        """
    
    def execute(self, target: str, scan_type: str = "common") -> Dict[str, Any]:
        """æ‰§è¡ŒçœŸå®çš„ç«¯å£æ‰«æ"""
        try:
            from real_security_tools import RealPortScanner
            
            scanner = RealPortScanner(timeout=1.0)
            
            if scan_type == "common":
                open_ports = scanner.scan_common_ports(target)
            elif scan_type == "quick":
                # å¿«é€Ÿæ‰«æï¼šåªæ‰«ææœ€å¸¸è§çš„ç«¯å£
                quick_ports = [21, 22, 80, 443, 3306, 8080]
                open_ports = scanner.scan_ports(target, quick_ports)
            elif scan_type == "full":
                # å…¨ç«¯å£æ‰«æï¼ˆ1-1000ï¼‰
                open_ports = scanner.scan_port_range(target, 1, 1000)
            else:
                open_ports = scanner.scan_common_ports(target)
            
            return {
                "target": target,
                "scan_time": datetime.now().isoformat(),
                "scan_type": scan_type,
                "ports": open_ports,
                "total_open_ports": len(open_ports)
            }
        
        except Exception as e:
            return {
                "target": target,
                "scan_time": datetime.now().isoformat(),
                "error": f"æ‰«æå¤±è´¥: {str(e)}",
                "ports": []
            }


class VulnScannerTool(SecurityToolInterface):
    """çœŸå®çš„æ¼æ´æ‰«æå·¥å…·"""
    
    def get_tool_description(self) -> str:
        return """
        vuln_scan(target: str, open_ports: List[dict]) -> List[dict]
        - å¯¹å¼€æ”¾ç«¯å£è¿›è¡ŒçœŸå®çš„æ¼æ´æ£€æµ‹
        - target: ç›®æ ‡IPæˆ–åŸŸå
        - open_ports: å¼€æ”¾ç«¯å£åˆ—è¡¨ï¼ˆä» nmap_scan è·å–ï¼‰
        - è¿”å›: æ¼æ´åˆ—è¡¨ï¼ŒåŒ…å«CVEç¼–å·ã€ä¸¥é‡ç¨‹åº¦ã€CVSSè¯„åˆ†ã€ä¿®å¤å»ºè®®ç­‰
        """
    
    def execute(self, target: str, open_ports: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """æ‰§è¡ŒçœŸå®çš„æ¼æ´æ‰«æ"""
        try:
            from real_security_tools import RealVulnScanner
            
            scanner = RealVulnScanner()
            vulnerabilities = scanner.scan_vulnerabilities(target, open_ports)
            
            return vulnerabilities
        
        except Exception as e:
            return [{
                "cve": "N/A",
                "severity": "info",
                "cvss": 0.0,
                "title": f"æ¼æ´æ‰«æå¤±è´¥: {str(e)}",
                "port": 0,
                "description": "æ— æ³•å®Œæˆæ¼æ´æ‰«æ",
                "recommendation": "æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œç›®æ ‡å¯è¾¾æ€§"
            }]


class WebCrawlerTool(SecurityToolInterface):
    """çœŸå®çš„ Web çˆ¬è™«å·¥å…·"""
    
    def get_tool_description(self) -> str:
        return """
        web_crawl(url: str, depth: int = 1, max_urls: int = 20) -> dict
        - çœŸå®çˆ¬å–ç½‘ç«™ç›®å½•ç»“æ„å’Œæ•æ„Ÿè·¯å¾„
        - url: ç›®æ ‡URLï¼ˆå¦‚ http://example.comï¼‰
        - depth: çˆ¬å–æ·±åº¦ï¼ˆé»˜è®¤1ï¼Œå»ºè®®ä¸è¶…è¿‡2ï¼‰
        - max_urls: æœ€å¤§çˆ¬å–URLæ•°é‡ï¼ˆé»˜è®¤20ï¼‰
        - è¿”å›: åŒ…å«URLåˆ—è¡¨ã€è¡¨å•ã€æ•æ„Ÿæ–‡ä»¶ç­‰ä¿¡æ¯
        """
    
    def execute(self, url: str, depth: int = 1, max_urls: int = 20) -> Dict[str, Any]:
        """æ‰§è¡ŒçœŸå®çš„Webçˆ¬è™«"""
        try:
            from real_security_tools import RealWebCrawler
            
            crawler = RealWebCrawler(max_depth=depth, max_urls=max_urls)
            result = crawler.crawl(url)
            
            # æ£€æŸ¥æ•æ„Ÿæ–‡ä»¶
            result["sensitive_files"] = crawler.check_sensitive_files(url)
            
            return result
        
        except Exception as e:
            return {
                "base_url": url,
                "error": f"çˆ¬å–å¤±è´¥: {str(e)}",
                "crawled_urls": [url],
                "found_urls": [],
                "forms": [],
                "sensitive_files": [],
                "total_urls": 1
            }


class SQLInjectionTool(SecurityToolInterface):
    """SQLæ³¨å…¥æ£€æµ‹å·¥å…·"""
    
    def get_tool_description(self) -> str:
        return """
        sql_injection_test(url: str, params: dict) -> dict
        - æµ‹è¯•SQLæ³¨å…¥æ¼æ´
        - url: ç›®æ ‡URL
        - params: è¦æµ‹è¯•çš„å‚æ•°å­—å…¸
        - è¿”å›: æ³¨å…¥ç‚¹ä¿¡æ¯å’ŒPayload
        """
    
    def execute(self, url: str, params: dict) -> Dict[str, Any]:
        """æ‰§è¡ŒSQLæ³¨å…¥æµ‹è¯•ï¼ˆæ¨¡æ‹Ÿå®ç°ï¼‰"""
        return {
            "vulnerable": True,
            "injection_point": "id",
            "payload": "1' OR '1'='1",
            "database_type": "MySQL",
            "exploitable": True
        }


# ============================================================
# 2. å·¥å…·ç®¡ç†å™¨
# ============================================================
class ToolManager:
    """ç®¡ç†æ‰€æœ‰å®‰å…¨å·¥å…·"""
    
    def __init__(self):
        self.tools: Dict[str, SecurityToolInterface] = {
            "nmap_scan": NmapTool(),
            "vuln_scan": VulnScannerTool(),
            "web_crawl": WebCrawlerTool(),
            "sql_injection_test": SQLInjectionTool(),
        }
    
    def get_tool(self, tool_name: str) -> Optional[SecurityToolInterface]:
        """è·å–æŒ‡å®šå·¥å…·"""
        return self.tools.get(tool_name)
    
    def get_all_tool_descriptions(self) -> str:
        """è·å–æ‰€æœ‰å·¥å…·çš„æè¿°ï¼Œç”¨äºæ„å»º LLM æç¤ºè¯"""
        descriptions = []
        for name, tool in self.tools.items():
            descriptions.append(f"### {name}\n{tool.get_tool_description()}")
        return "\n\n".join(descriptions)
    
    def execute_tool(self, tool_name: str, *args, **kwargs) -> Any:
        """æ‰§è¡ŒæŒ‡å®šå·¥å…·"""
        tool = self.get_tool(tool_name)
        if tool:
            return tool.execute(*args, **kwargs)
        else:
            raise ValueError(f"å·¥å…· '{tool_name}' ä¸å­˜åœ¨")


# ============================================================
# 3. å®‰å…¨æ²™ç®±æ‰§è¡Œå™¨
# ============================================================
class SecureCodeSandbox:
    """
    å®‰å…¨ä»£ç æ‰§è¡Œæ²™ç®±
    - é™åˆ¶å¯ç”¨çš„å†…ç½®å‡½æ•°å’Œæ¨¡å—
    - æ•è·æ‰§è¡Œè¾“å‡ºå’Œé”™è¯¯
    - æå– report å˜é‡ä½œä¸ºæœ€ç»ˆç»“æœ
    """
    
    def __init__(self, tool_manager: ToolManager):
        self.tool_manager = tool_manager
        
        # å®šä¹‰å®‰å…¨çš„å†…ç½®å‡½æ•°ç™½åå•
        self.safe_builtins = {
            'print': print,
            'len': len,
            'range': range,
            'str': str,
            'int': int,
            'float': float,
            'bool': bool,
            'list': list,
            'dict': dict,
            'set': set,
            'tuple': tuple,
            'sorted': sorted,
            'filter': filter,
            'map': map,
            'sum': sum,
            'min': min,
            'max': max,
            'abs': abs,
            'round': round,
            'enumerate': enumerate,
            'zip': zip,
            'any': any,
            'all': all,
            'isinstance': isinstance,
            'type': type,
        }
    
    def execute(self, code: str) -> Dict[str, Any]:
        """
        åœ¨æ²™ç®±ä¸­æ‰§è¡Œä»£ç 
        
        Args:
            code: Python ä»£ç å­—ç¬¦ä¸²
            
        Returns:
            åŒ…å«æ‰§è¡ŒçŠ¶æ€ã€ç»“æœã€è¾“å‡ºå’Œé”™è¯¯çš„å­—å…¸
        """
        # å‡†å¤‡æ‰§è¡Œç¯å¢ƒ
        exec_globals = {
            '__builtins__': self.safe_builtins,
            'tools': self._create_tools_proxy(),
            'json': json,
        }
        exec_locals = {}
        
        result = {
            "success": False,
            "report": None,
            "stdout": [],
            "error": None,
            "execution_time": None
        }
        
        # æ•è· print è¾“å‡º
        captured_output = []
        
        def capture_print(*args, **kwargs):
            output = ' '.join(str(arg) for arg in args)
            captured_output.append(output)
        
        exec_globals['__builtins__']['print'] = capture_print
        
        start_time = datetime.now()
        
        try:
            # æ‰§è¡Œä»£ç 
            exec(code, exec_globals, exec_locals)
            
            # æå– report å˜é‡
            if 'report' in exec_locals:
                result["success"] = True
                result["report"] = exec_locals['report']
            else:
                result["success"] = False
                result["error"] = "ä»£ç æ‰§è¡Œå®Œæˆï¼Œä½†æœªæ‰¾åˆ° 'report' å˜é‡"
            
            result["stdout"] = captured_output
            
        except Exception as e:
            result["success"] = False
            result["error"] = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
            result["stdout"] = captured_output
        
        end_time = datetime.now()
        result["execution_time"] = (end_time - start_time).total_seconds()
        
        return result
    
    def _create_tools_proxy(self):
        """åˆ›å»ºå·¥å…·ä»£ç†å¯¹è±¡ï¼Œä¾›æ²™ç®±ä»£ç è°ƒç”¨"""
        class ToolsProxy:
            def __init__(self, tool_manager):
                self.tool_manager = tool_manager
            
            def __getattr__(self, name):
                def tool_wrapper(*args, **kwargs):
                    return self.tool_manager.execute_tool(name, *args, **kwargs)
                return tool_wrapper
        
        return ToolsProxy(self.tool_manager)


# ============================================================
# 4. LLM æ¥å£å±‚
# ============================================================
class LLMInterface(ABC):
    """LLM æŠ½è±¡æ¥å£"""
    
    @abstractmethod
    def generate_code(self, prompt: str, context: List[Dict[str, str]] = None) -> str:
        """ç”Ÿæˆä»£ç """
        pass


class MockLLM(LLMInterface):
    """æ¨¡æ‹Ÿ LLMï¼ˆç”¨äºæµ‹è¯•ï¼‰"""
    
    def generate_code(self, prompt: str, context: List[Dict[str, str]] = None) -> str:
        """è¿”å›é¢„å®šä¹‰çš„æµ‹è¯•ä»£ç  - ä½¿ç”¨çœŸå®å·¥å…·"""
        # ä» prompt ä¸­æå–ç›®æ ‡
        target = "192.168.1.1"  # é»˜è®¤ç›®æ ‡
        if "ç›®æ ‡" in prompt or "target" in prompt.lower():
            import re
            # å°è¯•ä» prompt ä¸­æå– IP æˆ–åŸŸå
            ip_match = re.search(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', prompt)
            domain_match = re.search(r'\b[a-zA-Z0-9][-a-zA-Z0-9]*\.[a-zA-Z]{2,}\b', prompt)
            
            if ip_match:
                target = ip_match.group(0)
            elif domain_match:
                target = domain_match.group(0)
        
        return f'''
# è‡ªåŠ¨ç”Ÿæˆçš„æ¸—é€æµ‹è¯•ä»£ç  - ä½¿ç”¨çœŸå®å·¥å…·
target = "{target}"

# 1. ç«¯å£æ‰«æï¼ˆçœŸå®æ‰«æï¼‰
print(f"[*] æ­£åœ¨æ‰«æç›®æ ‡: {{target}}")
scan_result = tools.nmap_scan(target, scan_type="common")

if "error" in scan_result:
    print(f"[!] ç«¯å£æ‰«æå¤±è´¥: {{scan_result['error']}}")
    report = {{
        "target": target,
        "error": scan_result['error'],
        "open_ports": [],
        "vulnerabilities": [],
        "risk_level": "unknown"
    }}
else:
    open_ports = scan_result.get("ports", [])
    print(f"[+] å‘ç° {{len(open_ports)}} ä¸ªå¼€æ”¾ç«¯å£")
    
    # 2. æ¼æ´æ‰«æï¼ˆçœŸå®æ£€æµ‹ï¼‰
    print("[*] æ­£åœ¨æ‰«ææ¼æ´...")
    vulnerabilities = tools.vuln_scan(target, open_ports)
    print(f"[+] å‘ç° {{len(vulnerabilities)}} ä¸ªæ½œåœ¨æ¼æ´")
    
    # 3. Web çˆ¬è™«ï¼ˆå¦‚æœæœ‰ HTTP æœåŠ¡ï¼‰
    web_info = None
    http_ports = [p for p in open_ports if p.get("service") in ["http", "https", "http-proxy", "https-alt"]]
    
    if http_ports:
        port = http_ports[0]["port"]
        protocol = "https" if port in [443, 8443] else "http"
        url = f"{{protocol}}://{{target}}:{{port}}"
        
        print(f"[*] æ­£åœ¨çˆ¬å– Web: {{url}}")
        web_info = tools.web_crawl(url, depth=1, max_urls=10)
        
        if "error" not in web_info:
            print(f"[+] çˆ¬å–äº† {{web_info.get('total_urls', 0)}} ä¸ªé¡µé¢")
    
    # 4. è®¡ç®—é£é™©ç­‰çº§
    risk_level = "low"
    if vulnerabilities:
        severities = [v.get("severity", "low") for v in vulnerabilities]
        if "critical" in severities:
            risk_level = "critical"
        elif "high" in severities:
            risk_level = "high"
        elif "medium" in severities:
            risk_level = "medium"
    
    # 5. ç”ŸæˆæŠ¥å‘Š
    report = {{
        "target": target,
        "scan_time": scan_result.get("scan_time"),
        "open_ports": open_ports,
        "vulnerabilities": vulnerabilities,
        "web_info": web_info,
        "risk_level": risk_level,
        "summary": {{
            "total_ports": len(open_ports),
            "total_vulnerabilities": len(vulnerabilities),
            "critical_vulns": len([v for v in vulnerabilities if v.get("severity") == "critical"]),
            "high_vulns": len([v for v in vulnerabilities if v.get("severity") == "high"]),
            "medium_vulns": len([v for v in vulnerabilities if v.get("severity") == "medium"]),
            "low_vulns": len([v for v in vulnerabilities if v.get("severity") == "low"])
        }}
    }}

print("[+] æ‰«æå®Œæˆï¼")
'''


class OpenAILLM(LLMInterface):
    """OpenAI GPT æ¥å£"""
    
    def __init__(self, api_key: str, model: str = "gpt-4", base_url: str = "https://api.openai.com/v1"):
        self.api_key = api_key
        self.model = model
        self.base_url = base_url
        # å®é™…ä½¿ç”¨æ—¶éœ€è¦å¯¼å…¥ openai åº“
        try:
            import openai
            self.client = openai.OpenAI(api_key=api_key, base_url=base_url)
        except ImportError:
            self.client = None
    
    def generate_code(self, prompt: str, context: List[Dict[str, str]] = None) -> str:
        """è°ƒç”¨ OpenAI API ç”Ÿæˆä»£ç """
        if not self.client:
            raise NotImplementedError("è¯·å®‰è£… openai åº“: pip install openai")
        
        try:
            # æ„å»ºæ¶ˆæ¯åˆ—è¡¨
            messages = [
                {
                    "role": "system",
                    "content": "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ¸—é€æµ‹è¯•ä¸“å®¶ï¼Œæ“…é•¿ç¼–å†™ Python ä»£ç è¿›è¡Œå®‰å…¨æµ‹è¯•ã€‚"
                }
            ]
            
            # æ·»åŠ ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœæœ‰çš„è¯ï¼Œè½¬æ¢ä¸ºå¯¹è¯å†å²ï¼‰
            if context:
                for ctx in context[-3:]:  # åªä¿ç•™æœ€è¿‘3æ¬¡ä¸Šä¸‹æ–‡
                    # context æ˜¯ Agent çš„æ‰§è¡Œå†å²ï¼Œä¸æ˜¯æ ‡å‡†çš„æ¶ˆæ¯æ ¼å¼
                    # æˆ‘ä»¬å°†å…¶è½¬æ¢ä¸ºç®€å•çš„æ–‡æœ¬æè¿°
                    if isinstance(ctx, dict) and ctx.get('summary'):
                        messages.append({
                            "role": "assistant",
                            "content": f"ä¹‹å‰çš„æ‰§è¡Œç»“æœ: {ctx.get('summary', '')}"
                        })
            
            # æ·»åŠ å½“å‰è¯·æ±‚
            messages.append({"role": "user", "content": prompt})
            
            response = self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=4000  # å¢åŠ åˆ° 4000ï¼Œé¿å…ä»£ç è¢«æˆªæ–­
            )
            
            return response.choices[0].message.content
        except Exception as e:
            raise Exception(f"OpenAI API è°ƒç”¨å¤±è´¥: {str(e)}")


# ============================================================
# 5. Agent æ ¸å¿ƒå¼•æ“
# ============================================================
class SmartPentestAgent:
    """æ™ºèƒ½æ¸—é€æµ‹è¯• Agent"""
    
    def __init__(self, llm: LLMInterface = None):
        self.tool_manager = ToolManager()
        self.sandbox = SecureCodeSandbox(self.tool_manager)
        self.llm = llm or MockLLM()
        self.context_window: List[Dict[str, Any]] = []
        self.max_iterations = 5  # æœ€å¤§è¿­ä»£æ¬¡æ•°
    
    def _build_prompt(self, user_request: str) -> str:
        """æ„å»º LLM æç¤ºè¯"""
        tool_descriptions = self.tool_manager.get_all_tool_descriptions()
        
        prompt = f"""
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ¸—é€æµ‹è¯• Agentã€‚ä½ çš„ä»»åŠ¡æ˜¯ç¼–å†™ç®€æ´çš„ Python ä»£ç æ¥å®Œæˆå®‰å…¨æµ‹è¯•ä»»åŠ¡ã€‚

## å¯ç”¨å·¥å…·ï¼ˆå·²å®ç°ï¼Œç›´æ¥è°ƒç”¨å³å¯ï¼‰
{tool_descriptions}

## é‡è¦æç¤º
- tools å¯¹è±¡å·²ç»å­˜åœ¨ï¼Œç›´æ¥ä½¿ç”¨ `tools.å·¥å…·å()` è°ƒç”¨
- ä¸è¦å®šä¹‰ Tools ç±»æˆ–ä»»ä½•å·¥å…·å‡½æ•°
- ä¸è¦å¯¼å…¥ä¸å¿…è¦çš„æ¨¡å—
- ä»£ç è¦ç®€æ´ï¼Œä¸è¦è¶…è¿‡ 50 è¡Œ

## ä»£ç ç¼–å†™è§„åˆ™
1. ç›´æ¥ä½¿ç”¨ `tools.nmap_scan(target, scan_type="common")` è¿›è¡Œç«¯å£æ‰«æ
2. ä½¿ç”¨ `tools.vuln_scan(target, open_ports)` è¿›è¡Œæ¼æ´æ‰«æ
3. ä½¿ç”¨ `tools.web_crawl(url, depth=1, max_urls=10)` è¿›è¡Œ Web çˆ¬è™«
4. **å¿…é¡»**å°†æœ€ç»ˆç»“æœèµ‹å€¼ç»™ `report` å˜é‡
5. ä½¿ç”¨ `print()` è¾“å‡ºå…³é”®ä¿¡æ¯

## æ•°æ®ç»“æ„è¯´æ˜
nmap_scan è¿”å›æ ¼å¼ï¼š
{{
    "target": "192.168.1.1",
    "scan_time": "2025-12-09T15:00:00",
    "ports": [
        {{"port": 80, "state": "open", "service": "http", "version": "nginx/1.18.0"}},
        {{"port": 443, "state": "open", "service": "https", "version": "nginx/1.18.0"}}
    ]
}}

vuln_scan è¿”å›æ ¼å¼ï¼š
[
    {{
        "cve": "CVE-2021-XXXX",
        "severity": "high",
        "cvss": 7.5,
        "title": "æ¼æ´æ ‡é¢˜",
        "port": 80,
        "description": "è¯¦ç»†æè¿°",
        "recommendation": "ä¿®å¤å»ºè®®"
    }}
]

## ä»£ç ç¤ºä¾‹
```python
# 1. ç«¯å£æ‰«æ
target = "192.168.138.1"
print(f"[*] æ‰«æç›®æ ‡: {{target}}")
scan_result = tools.nmap_scan(target, scan_type="common")
open_ports = scan_result.get("ports", [])
print(f"[+] å‘ç° {{len(open_ports)}} ä¸ªå¼€æ”¾ç«¯å£")

# æ³¨æ„ï¼šopen_ports æ˜¯å­—å…¸åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ {{"port": 80, "service": "http", ...}}
for port_info in open_ports:
    print(f"    ç«¯å£ {{port_info['port']}}: {{port_info['service']}}")

# 2. æ¼æ´æ‰«æ
vulnerabilities = tools.vuln_scan(target, open_ports)
print(f"[+] å‘ç° {{len(vulnerabilities)}} ä¸ªæ¼æ´")

# 3. ç”ŸæˆæŠ¥å‘Š
report = {{
    "target": target,
    "scan_time": scan_result.get("scan_time"),
    "open_ports": open_ports,
    "vulnerabilities": vulnerabilities,
    "risk_level": "high" if any(v.get("severity") == "critical" for v in vulnerabilities) else "medium"
}}
```

## ç”¨æˆ·è¯·æ±‚
{user_request}

## ä¸Šä¸‹æ–‡ä¿¡æ¯
{self._format_context()}

è¯·ç›´æ¥è¾“å‡ºå¯æ‰§è¡Œçš„ Python ä»£ç ï¼Œä¸è¦åŒ…å« markdown ä»£ç å—æ ‡è®°ï¼Œä¸è¦å®šä¹‰å·¥å…·ç±»ã€‚
"""
        return prompt
    
    def _format_context(self) -> str:
        """æ ¼å¼åŒ–ä¸Šä¸‹æ–‡çª—å£"""
        if not self.context_window:
            return "æ— "
        
        context_str = []
        for i, ctx in enumerate(self.context_window[-3:], 1):  # åªä¿ç•™æœ€è¿‘3æ¬¡
            context_str.append(f"ç¬¬{i}æ¬¡æ‰§è¡Œ: {ctx.get('summary', 'æ— ')}")
        return "\n".join(context_str)
    
    def _clean_code(self, code: str) -> str:
        """æ¸…ç† LLM ç”Ÿæˆçš„ä»£ç ï¼Œç§»é™¤ markdown æ ‡è®°"""
        import re
        
        # ç§»é™¤ markdown ä»£ç å—æ ‡è®°
        # åŒ¹é… ```python ... ``` æˆ– ``` ... ```
        code = re.sub(r'^```(?:python)?\s*\n', '', code, flags=re.MULTILINE)
        code = re.sub(r'\n```\s*$', '', code, flags=re.MULTILINE)
        
        # ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½
        code = code.strip()
        
        return code
    
    def run(self, user_request: str, auto_iterate: bool = True) -> Dict[str, Any]:
        """
        æ‰§è¡Œæ¸—é€æµ‹è¯•ä»»åŠ¡
        
        Args:
            user_request: ç”¨æˆ·è¯·æ±‚æè¿°
            auto_iterate: æ˜¯å¦è‡ªåŠ¨è¿­ä»£æ‰§è¡Œ
            
        Returns:
            æ‰§è¡Œç»“æœå­—å…¸
        """
        print("\n" + "="*60)
        print(f"[Agent] æ”¶åˆ°ä»»åŠ¡: {user_request}")
        print("="*60)
        
        iteration = 0
        final_result = None
        
        while iteration < self.max_iterations:
            iteration += 1
            print(f"\n[Agent] ç¬¬ {iteration} æ¬¡è¿­ä»£")
            
            # 1. æ„å»ºæç¤ºè¯
            prompt = self._build_prompt(user_request)
            
            # 2. è°ƒç”¨ LLM ç”Ÿæˆä»£ç 
            print("[Agent] æ­£åœ¨ç”Ÿæˆä»£ç ...")
            code = self.llm.generate_code(prompt, self.context_window)
            
            # æ¸…ç†ä»£ç ï¼šç§»é™¤ markdown ä»£ç å—æ ‡è®°
            code = self._clean_code(code)
            
            print("\n[ç”Ÿæˆçš„ä»£ç ]")
            print("-" * 40)
            print(code)
            print("-" * 40)
            
            # 3. åœ¨æ²™ç®±ä¸­æ‰§è¡Œä»£ç 
            print("\n[Agent] åœ¨æ²™ç®±ä¸­æ‰§è¡Œ...")
            result = self.sandbox.execute(code)
            
            # 4. è®°å½•åˆ°ä¸Šä¸‹æ–‡
            self.context_window.append({
                "iteration": iteration,
                "code": code,
                "result": result,
                "summary": f"æ‰§è¡Œ{'æˆåŠŸ' if result['success'] else 'å¤±è´¥'}"
            })
            
            # 5. æ£€æŸ¥æ‰§è¡Œç»“æœ
            if result["success"]:
                print(f"[Agent] âœ… æ‰§è¡ŒæˆåŠŸ (è€—æ—¶: {result['execution_time']:.2f}s)")
                final_result = result
                
                if not auto_iterate:
                    break
                
                # åˆ¤æ–­æ˜¯å¦éœ€è¦ç»§ç»­è¿­ä»£
                # è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„é€»è¾‘ï¼Œæ¯”å¦‚æ£€æŸ¥æ˜¯å¦å‘ç°äº†æ–°çš„æ”»å‡»é¢
                break
            else:
                print(f"[Agent] âŒ æ‰§è¡Œå¤±è´¥: {result['error']}")
                if not auto_iterate:
                    final_result = result
                    break
        
        print("\n" + "="*60)
        print("[Agent] ä»»åŠ¡å®Œæˆ")
        print("="*60)
        
        return final_result or {"success": False, "error": "è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°"}
    
    def clear_context(self):
        """æ¸…ç©ºä¸Šä¸‹æ–‡çª—å£"""
        self.context_window.clear()


# ============================================================
# 6. ä¸»ç¨‹åºå…¥å£
# ============================================================
def main():
    """ä¸»å‡½æ•°"""
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          æ™ºèƒ½æ¸—é€æµ‹è¯• Agent ç³»ç»Ÿ v1.0                         â•‘
â•‘     åŸºäº LLM + ä»£ç ç”Ÿæˆ + æ²™ç®±æ‰§è¡Œ                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    # åˆ›å»º Agentï¼ˆä½¿ç”¨æ¨¡æ‹Ÿ LLMï¼‰
    agent = SmartPentestAgent(llm=MockLLM())
    
    # ç¤ºä¾‹ä»»åŠ¡
    user_request = "æ‰«æ example.com å¹¶æ£€æµ‹æ‰€æœ‰é«˜å±æ¼æ´"
    
    # æ‰§è¡Œä»»åŠ¡
    result = agent.run(user_request)
    
    # æ˜¾ç¤ºç»“æœ
    print("\n" + "="*60)
    print("æœ€ç»ˆæŠ¥å‘Š")
    print("="*60)
    
    if result["success"]:
        print("\nâœ… ä»»åŠ¡æ‰§è¡ŒæˆåŠŸï¼")
        print("\nğŸ“‹ æ¸—é€æµ‹è¯•æŠ¥å‘Š:")
        print(json.dumps(result["report"], indent=2, ensure_ascii=False))
    else:
        print("\nâŒ ä»»åŠ¡æ‰§è¡Œå¤±è´¥")
        print(f"é”™è¯¯ä¿¡æ¯: {result['error']}")
    
    if result.get("stdout"):
        print("\nğŸ“ æ‰§è¡Œæ—¥å¿—:")
        for line in result["stdout"]:
            print(f"  {line}")


if __name__ == "__main__":
    main()
